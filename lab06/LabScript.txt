# Lab 06: Object-Oriented Thinking and Python Standard Library Objects

## Instructor Lab Script

**Course**: Introduction to Programming and Computer Science I
**Lab**: 06 - Object-Oriented Thinking and Standard Library Objects
**Duration**: 3 weeks (6-9 hours of student work)
**Prerequisites**: Labs 01-05 (especially Lab 04: Data Structures and Lab 05: JSON/APIs)

---

## Lab Philosophy and Pedagogical Approach

### Why This Lab Now?

Lab 06 represents a crucial pivot point in the course progression. Students have mastered:
- Basic programming constructs (variables, functions, control flow)
- Core data structures (strings, lists, dictionaries)
- Data serialization and external APIs (JSON, HTTP requests)
- File operations and data persistence

**The Gap**: Students have been *using* objects (strings, lists, dicts) but haven't formally understood the **object-oriented paradigm**—that programming is fundamentally about objects that encapsulate data and behavior.

**This Lab's Mission**: Bridge procedural thinking to object-oriented thinking through Python's standard library. Rather than diving immediately into class definitions (which can be abstract and confusing), we leverage familiar, practical library objects to build intuition about:
1. **Objects as message receivers** (the dot notation philosophy)
2. **APIs as structured contracts** (consistent patterns across library modules)
3. **Encapsulation** (data + behavior bundled together)
4. **Exploration skills** (using `dir()`, `help()`, and documentation)

This approach follows the principle: **"Use objects before you build objects."** Students gain confidence working with well-designed library objects, preparing them to create their own classes in Lab 07.

---

## Learning Objectives Breakdown

### Primary Objectives (Core Competencies)

By the end of this lab, students will be able to:

1. **Conceptual Understanding**
   - ✅ Explain the difference between primitive values and reference types
   - ✅ Understand that all Python data are objects with identity, type, and value
   - ✅ Articulate the "objects receive messages" mental model
   - ✅ Distinguish between methods (object behavior) and functions (standalone procedures)

2. **Technical Skills**
   - ✅ Use `type()`, `id()`, `is`, and `isinstance()` to inspect objects
   - ✅ Navigate API documentation to discover and use object methods
   - ✅ Apply dot notation to invoke methods on objects
   - ✅ Chain method calls for fluent interfaces
   - ✅ Import and use standard library modules effectively

3. **Practical Application**
   - ✅ Work with `datetime` objects for date/time operations
   - ✅ Use `pathlib.Path` for cross-platform file system operations
   - ✅ Leverage `collections` module for specialized data structures
   - ✅ Apply `random` module for probabilistic operations
   - ✅ Implement proper file handling with context managers (`with` statement)
   - ✅ Use type hints to improve code clarity and documentation

4. **Problem-Solving**
   - ✅ Break down real-world problems into object-oriented solutions
   - ✅ Select appropriate library objects for specific tasks
   - ✅ Debug object-related errors (AttributeError, TypeError)
   - ✅ Build modular, maintainable code using library objects

### Secondary Objectives (Advanced Extensions)

For students who complete core content quickly:
- Explore `itertools` for advanced iteration patterns
- Implement custom `__str__` and `__repr__` methods (preview of Lab 07)
- Use `dataclasses` for structured data (gentle OOP introduction)
- Apply functional programming patterns with library objects

---

## Module-by-Module Instructor Guide

### Module 1: Variables and Types Review (Consolidation)
**Files**: `01_Variables_Types_Review.md`, `01_Variables_Types_Review.ipynb`
**Estimated Time**: 60-90 minutes

#### Pedagogical Intent
This module isn't just a review—it's a **reconceptualization** of variables. Students have used variables procedurally; now they must understand variables as *references to objects*. This is critical for understanding:
- Why `list.append()` modifies in place
- Why `string.upper()` returns a new string
- Memory efficiency and copy vs. view semantics

#### Key Teaching Points

1. **Everything is an Object**
   ```python
   x = 42
   print(type(x))  # <class 'int'>
   print(id(x))    # Memory address
   print(dir(x))   # Available methods!
   ```
   **Insight**: Even integers have methods! This challenges the "primitive vs. object" distinction from other languages.

2. **Identity vs. Equality**
   ```python
   a = [1, 2, 3]
   b = [1, 2, 3]
   c = a

   print(a == b)  # True (same values)
   print(a is b)  # False (different objects)
   print(a is c)  # True (same object)
   ```
   **Common Mistake**: Students confuse `==` (value equality) with `is` (identity). Emphasize: `is` checks if two names point to the *same object in memory*.

3. **Mutability Hierarchy**
   ```python
   # Immutable: int, float, str, tuple, frozenset
   name = "Alice"
   name.upper()  # Returns NEW string, doesn't modify original

   # Mutable: list, dict, set
   numbers = [1, 2, 3]
   numbers.append(4)  # Modifies IN PLACE
   ```
   **Teaching Strategy**: Use the "box analogy"—immutable objects are sealed boxes (you get a new box for changes), mutable objects have doors (you can change contents).

4. **Type Checking Patterns**
   ```python
   # Runtime type checking
   if isinstance(data, list):
       data.append(value)

   # Type hints (documentation + IDE support)
   def process_names(names: list[str]) -> int:
       return len(names)
   ```
   **Why Now**: Type hints prepare students for working with library APIs that use them extensively.

#### Embedded Exercises (6 Problems)

1. **Identity Detective**: Predict `is` vs. `==` results for various assignments
2. **Mutation Station**: Identify which operations create new objects vs. modify in place
3. **Type Explorer**: Use `type()`, `dir()`, and `help()` on various objects
4. **Reference Puzzle**: Debug aliasing issues in nested data structures
5. **Type Annotation Practice**: Add type hints to functions
6. **Memory Model Drawing**: Visualize variable references (use Python Tutor)

#### Common Student Struggles

**Problem**: "Why does `my_string.upper()` not change `my_string`?"
**Solution**: Demonstrate that strings are immutable; show the return value vs. in-place modification distinction.

**Problem**: "When do I use `is` vs. `==`?"
**Solution**: Rule of thumb: Use `==` for value comparison (99% of cases), `is` only for `None` checks or checking if two names reference the *exact same object*.

**Problem**: "What are type hints for if Python doesn't enforce them?"
**Solution**: Three benefits: (1) IDE autocomplete/error detection, (2) self-documentation, (3) tools like `mypy` can check them. It's professional practice.

---

### Module 2: Objects and Methods Fundamentals
**Files**: `02_Objects_Methods.md`, `02_Objects_Methods.ipynb`
**Estimated Time**: 75-90 minutes

#### Pedagogical Intent
This module formalizes the **dot notation paradigm**: `object.method()` as "sending a message to an object." Students have used this syntax hundreds of times; now they understand *why* it works this way. This sets the foundation for:
- Reading API documentation
- Understanding object-oriented design principles
- Creating their own classes (Lab 07)

#### Key Teaching Points

1. **Methods vs. Functions: The Crucial Distinction**
   ```python
   # Function: standalone procedure
   len([1, 2, 3])  # Function takes object as argument

   # Method: behavior bound to an object
   [1, 2, 3].count(2)  # Object performs action on itself
   ```
   **Mental Model**: Methods are "verbs that objects can perform" or "messages objects can receive."

2. **The Dot Notation Philosophy**
   ```python
   # Reading: "Ask the 'name' object to execute its 'upper' method"
   result = name.upper()

   # NOT: "Run the function 'upper' on 'name'"
   ```
   **Why This Matters**: This mental shift is the essence of OOP. Objects are active agents, not passive data.

3. **Object State and Behavior**
   ```python
   from datetime import datetime

   now = datetime.now()  # Object creation
   print(now.year)       # Accessing state (attribute)
   print(now.strftime("%Y-%m-%d"))  # Invoking behavior (method)
   ```
   **Key Insight**: Objects bundle data (state) and operations (behavior). You don't pass the date to a formatting function; you *ask the date object to format itself*.

4. **Method Chaining (Fluent Interfaces)**
   ```python
   # Immutable objects return new objects (chainable)
   result = text.strip().lower().replace(" ", "_")

   # Mutable objects modify in place (not always chainable)
   numbers = [3, 1, 2]
   numbers.sort()  # Returns None! (modifies in place)
   ```
   **Teaching Moment**: Discuss design trade-offs. Why does `list.sort()` return `None`? (Prevents confusion about in-place vs. new object.)

5. **Exploration with `dir()` and `help()`**
   ```python
   # Discover available methods
   text = "hello"
   print([m for m in dir(text) if not m.startswith('_')])

   # Get detailed documentation
   help(text.split)
   ```
   **Skill Building**: Teach students to be self-sufficient explorers of APIs, not reliant on memorization.

#### Embedded Exercises (5 Problems)

1. **Method Hunt**: Given an object, use `dir()` to find methods matching specific criteria (e.g., all methods with "count" in the name)
2. **Method vs. Function Sort**: Categorize code snippets as method calls or function calls
3. **Chain Reaction**: Rewrite nested function calls as method chains
4. **State vs. Behavior**: Identify attributes vs. methods in object inspection
5. **Documentation Deep Dive**: Use `help()` to solve a problem without looking at tutorials

#### Common Student Struggles

**Problem**: "Why do some methods return `None`?"
**Solution**: Convention: Mutable objects that modify in place return `None` to signal "I changed myself." Immutable objects must return new objects.

**Problem**: "How do I know which methods an object has?"
**Solution**: Three sources: (1) `dir(obj)` for exploration, (2) IDE autocomplete, (3) official documentation (teach how to read docs.python.org structure).

**Problem**: Confusion between attributes (data) and methods (behavior)
**Solution**: Methods have parentheses `()`, attributes don't. Methods *do things*, attributes *are things*.

---

### Module 3: Python Standard Library - Core Objects
**Files**: `03_Standard_Library_Objects.md`, `03_Standard_Library_Objects.ipynb`
**Estimated Time**: 90-120 minutes

#### Pedagogical Intent
This is the **practical heart** of the lab. Students learn to work with Python's most essential library objects, discovering that well-designed APIs follow consistent patterns. By working with multiple modules, students internalize:
- How to read and understand API documentation
- Common method naming conventions (`.get()`, `.add()`, `.remove()`)
- The power of specialized objects over primitive types

#### Module Coverage

##### 1. `datetime` Module
**Why Teach This**: Date/time handling is ubiquitous in real-world programming, and `datetime` objects are well-designed, method-rich examples of OOP.

```python
from datetime import datetime, timedelta, date

# Creating datetime objects
now = datetime.now()
birthday = datetime(1995, 8, 15, 14, 30)

# Object state (attributes)
print(now.year, now.month, now.day)
print(now.hour, now.minute)

# Object behavior (methods)
formatted = now.strftime("%B %d, %Y at %I:%M %p")
print(formatted)  # "October 16, 2025 at 03:45 PM"

# Date arithmetic with timedelta
tomorrow = now + timedelta(days=1)
age = now - birthday
print(f"Age: {age.days} days")
```

**Key Teaching Points**:
- **Immutability**: `datetime` objects are immutable (like strings). Operations return new objects.
- **Rich API**: Demonstrate `strptime()` (parsing), `strftime()` (formatting), `.replace()`, `.weekday()`, etc.
- **Real-World Application**: Build a "days until" calculator, birthday tracker, or task deadline manager.

**Common Pitfalls**:
- Confusing `datetime.datetime` vs. `datetime.date` vs. `datetime.time`
- Timezone handling (mention but don't deep-dive; suggest `zoneinfo` for advanced students)
- String formatting codes (`%Y` vs. `%y`, `%m` vs. `%b`)

**Exercise Ideas**:
1. Calculate age in years, months, and days
2. Parse log file timestamps
3. Create a countdown timer to an event
4. Find all Fridays in the next year

##### 2. `pathlib.Path` Module
**Why Teach This**: Modern, object-oriented file path handling that's cross-platform and safer than string manipulation.

```python
from pathlib import Path

# Creating Path objects
current_dir = Path.cwd()
home = Path.home()
file_path = Path("data/students.json")

# Object state
print(file_path.name)        # "students.json"
print(file_path.stem)        # "students"
print(file_path.suffix)      # ".json"
print(file_path.parent)      # "data"

# Object behavior
print(file_path.exists())
print(file_path.is_file())
file_path.mkdir(parents=True, exist_ok=True)  # Create directory

# Path operations (operator overloading!)
new_path = current_dir / "data" / "output.txt"
```

**Key Teaching Points**:
- **Cross-Platform**: No more `os.path.join()` or manual `\` vs. `/` handling
- **Readable**: `path.stem` vs. `os.path.splitext(os.path.basename(path))[0]`
- **Safe**: Built-in existence checks, error handling
- **Operator Overloading**: The `/` operator for path joining is elegant (preview of operator magic methods)

**Common Pitfalls**:
- Forgetting that `Path` objects aren't strings (use `str(path)` when needed)
- Confusing relative vs. absolute paths
- Not checking `.exists()` before file operations

**Exercise Ideas**:
1. Build a file organizer (sort files by extension)
2. Find all `.py` files in a directory tree
3. Create a backup system (copy files with timestamp)
4. Calculate total size of all files in a directory

##### 3. `random` Module
**Why Teach This**: Introduces non-deterministic behavior, useful for simulations, games, and testing.

```python
import random

# Basic random number generation
print(random.randint(1, 10))    # Integer between 1-10
print(random.random())           # Float between 0.0-1.0
print(random.uniform(5.0, 10.0)) # Float between 5.0-10.0

# Random selection
colors = ["red", "green", "blue"]
print(random.choice(colors))           # Single choice
print(random.choices(colors, k=3))     # Multiple with replacement
print(random.sample(colors, k=2))      # Multiple without replacement

# Shuffling
deck = list(range(1, 53))
random.shuffle(deck)  # In-place mutation!

# Seeding (reproducibility)
random.seed(42)  # Same seed = same sequence
```

**Key Teaching Points**:
- **Randomness in Computing**: Pseudo-random vs. true random
- **Seeding for Testing**: How to make "random" code reproducible
- **Method Variety**: Different methods for different use cases
- **Mutable Operations**: `shuffle()` modifies in place

**Common Pitfalls**:
- Not understanding the difference between `choice()`, `choices()`, and `sample()`
- Forgetting that `shuffle()` modifies the list (returns `None`)
- Over-seeding (seeding in loops makes every iteration identical)

**Exercise Ideas**:
1. Dice rolling simulator
2. Password generator
3. Random quiz question selector
4. Monte Carlo simulation (estimate π)

##### 4. `collections` Module
**Why Teach This**: Specialized data structures that extend dict/list functionality, demonstrating that the standard library provides more than basic types.

```python
from collections import Counter, defaultdict, deque, namedtuple

# Counter: Frequency counting made easy
text = "hello world"
letter_counts = Counter(text)
print(letter_counts.most_common(3))  # Top 3 letters

# defaultdict: No more KeyError on missing keys
word_index = defaultdict(list)
word_index["hello"].append(0)  # Auto-creates empty list

# deque: Double-ended queue (efficient at both ends)
queue = deque([1, 2, 3])
queue.append(4)      # Add to right
queue.appendleft(0)  # Add to left
queue.pop()          # Remove from right
queue.popleft()      # Remove from left

# namedtuple: Lightweight objects with named fields
Student = namedtuple('Student', ['name', 'id', 'gpa'])
alice = Student(name="Alice", id="12345", gpa=3.8)
print(alice.name)  # Readable attribute access
```

**Key Teaching Points**:
- **Right Tool for the Job**: Don't reinvent the wheel; use specialized collections
- **Counter**: Replaces manual frequency counting loops
- **defaultdict**: Cleaner code when building up dictionaries
- **deque**: Pronounced "deck," efficient for queue/stack operations
- **namedtuple**: Lightweight alternative to full classes (preview of `dataclasses`)

**Common Pitfalls**:
- Not knowing these exist (students reinvent them with dicts/lists)
- Confusion about when to use `Counter` vs. manual dict approach
- `namedtuple` immutability surprise

**Exercise Ideas**:
1. Analyze log files (word frequency with Counter)
2. Build a task queue (deque for job scheduling)
3. Inventory system (defaultdict for categories)
4. Student records (namedtuple vs. dict comparison)

#### Integrated Exercises (Module 3)

**Exercise 1: Task Scheduler**
Build a task management system using `datetime` and `collections`:
- Store tasks with due dates
- Mark tasks as complete
- List overdue tasks
- Calculate average completion time

**Exercise 2: File Organizer**
Create a utility that organizes files by type using `pathlib`:
- Scan directory for files
- Group by extension
- Move to organized folders
- Generate report of organization

**Exercise 3: Data Generator**
Build a test data generator using `random`:
- Generate fake student records
- Create realistic grade distributions
- Produce sample transaction data
- Export to JSON

---

### Module 4: More Standard Library Objects
**Files**: `04_Advanced_Library_Objects.md`, `04_Advanced_Library_Objects.ipynb`
**Estimated Time**: 90-120 minutes

#### Pedagogical Intent
This module reinforces the patterns from Module 3 while introducing slightly more advanced concepts. Students gain confidence working with diverse APIs and see the consistency across Python's standard library.

#### Module Coverage

##### 1. `json` Module (Reinforcement from Lab 05)
**Why Revisit**: Frame JSON operations as working with the `json` object's methods, reinforcing the object-oriented perspective.

```python
import json

# The json module as an object with methods
data = {"name": "Alice", "scores": [85, 92, 78]}

# Serialization methods
json_string = json.dumps(data, indent=2)
with open("data.json", "w") as f:
    json.dump(data, f, indent=2)

# Deserialization methods
parsed = json.loads(json_string)
with open("data.json", "r") as f:
    loaded = json.load(f)
```

**New Angle**: Discuss the module itself as an API—consistent naming (`dump` vs. `dumps`, `load` vs. `loads`), consistent parameter patterns.

##### 2. `math` and `statistics` Modules
**Why Teach This**: Scientific computing basics, demonstrate domain-specific object modules.

```python
import math
import statistics

# math module: Mathematical functions
print(math.pi, math.e)
print(math.sqrt(16), math.pow(2, 3))
print(math.ceil(4.3), math.floor(4.7))
print(math.sin(math.radians(90)))  # Trigonometry

# statistics module: Data analysis
data = [85, 92, 78, 90, 88, 95]
print(statistics.mean(data))
print(statistics.median(data))
print(statistics.stdev(data))  # Standard deviation
print(statistics.mode([1, 1, 2, 3, 3, 3]))
```

**Key Teaching Points**:
- **Constants**: `math.pi`, `math.e` as module attributes
- **Domain Specificity**: Different modules for different mathematical domains
- **Real-World Use**: Data analysis, scientific calculations, financial modeling

**Exercise Ideas**:
1. Calculate compound interest with `math.pow()`
2. Analyze test score distributions with `statistics`
3. Geometry calculator (circle, triangle calculations)
4. Financial calculator (loan payments, ROI)

##### 3. `itertools` Module (Advanced)
**Why Teach This**: Functional programming patterns, efficient iteration, prepares for advanced Python.

```python
from itertools import count, cycle, repeat, chain, combinations, permutations

# Infinite iterators
for i in count(start=10, step=2):
    print(i)
    if i > 20: break  # 10, 12, 14, 16, 18, 20

# Cycling through sequences
colors = cycle(['red', 'green', 'blue'])
print([next(colors) for _ in range(5)])  # ['red', 'green', 'blue', 'red', 'green']

# Combinatorics
items = ['A', 'B', 'C']
print(list(combinations(items, 2)))  # [('A', 'B'), ('A', 'C'), ('B', 'C')]
print(list(permutations(items, 2)))  # [('A', 'B'), ('A', 'C'), ('B', 'A'), ...]

# Chaining iterables
combined = chain([1, 2], [3, 4], [5, 6])
print(list(combined))  # [1, 2, 3, 4, 5, 6]
```

**Key Teaching Points**:
- **Lazy Evaluation**: Iterators generate values on-demand (memory efficient)
- **Infinite Sequences**: Some iterators never end (use carefully!)
- **Combinatorics**: Powerful tools for generating combinations/permutations
- **Functional Style**: Composing operations instead of loops

**Common Pitfalls**:
- Infinite iterators without break conditions
- Forgetting that iterators are one-time-use (exhaustible)
- Performance misunderstandings (when to use vs. list comprehensions)

**Exercise Ideas**:
1. Generate lottery number combinations
2. Create rotating schedules (duty roster)
3. Build a card deck permutation generator
4. Implement pagination with `islice()`

##### 4. `typing` Module (Modern Python)
**Why Teach This**: Professional code quality, IDE support, gradual typing.

```python
from typing import List, Dict, Tuple, Optional, Union, Any

# Type hints for collections
def process_scores(scores: List[float]) -> float:
    return sum(scores) / len(scores)

# Optional types (can be None)
def find_student(student_id: str) -> Optional[Dict[str, Any]]:
    # Returns dict or None
    pass

# Union types (multiple possible types)
def format_value(value: Union[int, float, str]) -> str:
    return str(value)

# Type aliases for complex types
StudentRecord = Dict[str, Union[str, int, List[float]]]

def process_student(student: StudentRecord) -> None:
    pass
```

**Key Teaching Points**:
- **Documentation Value**: Type hints are executable documentation
- **IDE Benefits**: Autocomplete, error detection, refactoring support
- **Gradual Typing**: Add hints where they help, not everywhere
- **Modern Standard**: Expected in professional Python code

**Common Pitfalls**:
- Over-typing (adding hints that don't add clarity)
- Confusing type hints with runtime enforcement (Python doesn't enforce by default)
- Not importing types from `typing` module

##### 5. `dataclasses` Module (Preview of Lab 07)
**Why Teach This**: Lightweight structured data, bridge to custom classes.

```python
from dataclasses import dataclass, field
from typing import List

@dataclass
class Student:
    name: str
    student_id: str
    gpa: float
    courses: List[str] = field(default_factory=list)

    def add_course(self, course: str) -> None:
        self.courses.append(course)

    def __str__(self) -> str:
        return f"{self.name} (ID: {self.student_id}, GPA: {self.gpa})"

# Usage
alice = Student(name="Alice", student_id="12345", gpa=3.8)
alice.add_course("COMP3083")
print(alice)  # Custom string representation
```

**Key Teaching Points**:
- **Boilerplate Reduction**: `@dataclass` auto-generates `__init__`, `__repr__`, etc.
- **Type Hints Required**: Dataclasses rely on type annotations
- **Methods Allowed**: Can add custom behavior beyond data storage
- **Preview of Classes**: Same syntax as full classes (coming in Lab 07)

**Teaching Strategy**: Introduce `dataclasses` as "structured dictionaries with methods." Don't deep-dive into class syntax yet; focus on practical use.

#### Integrated Exercises (Module 4)

**Exercise 1: Data Analyzer**
Build a statistical analysis tool:
- Read numeric data from JSON files
- Calculate mean, median, mode, standard deviation
- Visualize distributions (text-based histogram)
- Export results with type-safe functions

**Exercise 2: Configuration Validator**
Create a config file validator with type hints:
- Define expected configuration structure with `typing`
- Parse JSON config files
- Validate types and ranges
- Generate error reports

**Exercise 3: Test Data Generator (Advanced)**
Build a sophisticated test data generator:
- Use `dataclasses` for record structure
- Generate realistic data with `random`
- Use `itertools` for combinations
- Export to multiple formats (JSON, CSV)

---

### Module 5: File and System Objects
**Files**: `05_File_System_Objects.md`, `05_File_System_Objects.ipynb`
**Estimated Time**: 75-90 minutes

#### Pedagogical Intent
This module solidifies file I/O skills introduced in Labs 03-05, but with a focus on **objects**: file objects, path objects, and context managers. Students learn that file handling is all about working with objects that manage resources.

#### Key Teaching Points

##### 1. File Objects and Context Managers
**The `with` Statement Paradigm**

```python
# OLD WAY (error-prone)
f = open("data.txt", "r")
content = f.read()
f.close()  # What if an error occurs before this?

# MODERN WAY (safe, automatic cleanup)
with open("data.txt", "r") as f:
    content = f.read()
# File automatically closed here, even if error occurs
```

**Why This Matters**: Context managers (`with` statement) are **the** Python idiom for resource management. This pattern appears in:
- File handling
- Database connections
- Network sockets
- Locks and threading

**Teaching Moment**: Explain the "resource leak" problem. If an exception occurs between `open()` and `close()`, the file remains open, consuming system resources.

##### 2. File Object Methods
```python
# Reading methods
with open("data.txt", "r") as f:
    all_content = f.read()           # Entire file as string
    f.seek(0)                        # Reset to beginning
    first_line = f.readline()        # Single line
    f.seek(0)
    all_lines = f.readlines()        # List of lines

# Writing methods
with open("output.txt", "w") as f:
    f.write("Hello, world!\n")       # Write string
    f.writelines(["Line 1\n", "Line 2\n"])  # Write multiple

# Iterating (most Pythonic)
with open("data.txt", "r") as f:
    for line in f:  # File objects are iterable!
        print(line.strip())
```

**Key Teaching Points**:
- **File Modes**: `r` (read), `w` (write/overwrite), `a` (append), `r+` (read/write), `rb` (binary)
- **Automatic Iteration**: File objects are iterable—no need for `readlines()`
- **Memory Efficiency**: Reading line-by-line vs. loading entire file
- **Text vs. Binary**: When to use binary mode

##### 3. Path Objects for File Operations (Integration)
```python
from pathlib import Path

# Object-oriented file operations
data_dir = Path("data")
data_dir.mkdir(exist_ok=True)  # Create if doesn't exist

file_path = data_dir / "students.json"

# Reading with Path objects
content = file_path.read_text()  # Convenience method

# Writing with Path objects
file_path.write_text(json.dumps(data, indent=2))

# Context manager for more control
with file_path.open("r") as f:
    data = json.load(f)
```

**Key Teaching Points**:
- **Convenience Methods**: `.read_text()`, `.write_text()`, `.read_bytes()`, `.write_bytes()`
- **When to Use**: Convenience methods for simple operations, context managers for complex
- **Elegance**: Compare `Path("data/file.txt").read_text()` vs. traditional approach

##### 4. Directory Operations
```python
from pathlib import Path

# List directory contents
for item in Path(".").iterdir():
    if item.is_file():
        print(f"File: {item.name}")
    elif item.is_dir():
        print(f"Directory: {item.name}")

# Glob patterns (find files matching pattern)
for json_file in Path("data").glob("*.json"):
    print(json_file)

# Recursive glob (search subdirectories)
for py_file in Path(".").rglob("*.py"):
    print(py_file)

# Create directory structure
output_dir = Path("output/reports/2025")
output_dir.mkdir(parents=True, exist_ok=True)
```

**Key Teaching Points**:
- **Iteration**: `.iterdir()` yields Path objects (can call methods on them)
- **Pattern Matching**: `.glob()` for simple patterns, `.rglob()` for recursive
- **Safe Creation**: `parents=True` creates intermediate directories, `exist_ok=True` prevents errors

##### 5. Reading Different Formats
```python
import json
import csv
from pathlib import Path

# JSON files
def read_json(file_path: Path) -> dict:
    with file_path.open("r") as f:
        return json.load(f)

def write_json(file_path: Path, data: dict) -> None:
    with file_path.open("w") as f:
        json.dump(data, f, indent=2)

# CSV files (preview; may save for later lab)
def read_csv(file_path: Path) -> list:
    with file_path.open("r") as f:
        reader = csv.DictReader(f)  # Returns dict objects!
        return list(reader)

def write_csv(file_path: Path, data: list, fieldnames: list) -> None:
    with file_path.open("w", newline="") as f:
        writer = csv.DictWriter(f, fieldnames=fieldnames)
        writer.writeheader()
        writer.writerows(data)

# Plain text files
def read_lines(file_path: Path) -> list:
    return file_path.read_text().splitlines()

def append_line(file_path: Path, line: str) -> None:
    with file_path.open("a") as f:
        f.write(line + "\n")
```

**Teaching Strategy**: Provide these as utility functions students can use in projects. Emphasize the consistent pattern:
1. Open file with context manager
2. Use appropriate method on file object
3. Automatic cleanup on exit

##### 6. Exception Handling with Files
```python
from pathlib import Path
import json

def safe_read_json(file_path: Path) -> dict | None:
    try:
        with file_path.open("r") as f:
            return json.load(f)
    except FileNotFoundError:
        print(f"Error: {file_path} not found")
        return None
    except json.JSONDecodeError as e:
        print(f"Error: Invalid JSON in {file_path}: {e}")
        return None
    except PermissionError:
        print(f"Error: No permission to read {file_path}")
        return None

# Usage
data = safe_read_json(Path("config.json"))
if data:
    process(data)
else:
    use_defaults()
```

**Key Teaching Points**:
- **Specific Exceptions**: Catch specific exceptions, not bare `except:`
- **Graceful Degradation**: Return `None` or default values on error
- **User-Friendly Messages**: Explain what went wrong
- **Context Manager Safety**: File still closes even if exception occurs

#### Embedded Exercises (Module 5)

1. **Log File Parser**: Read log files, extract errors, generate summary report
2. **Configuration Manager**: Read/write config files with validation
3. **Bulk File Processor**: Process all files in directory matching pattern
4. **Backup System**: Copy files to backup directory with timestamp
5. **Directory Tree Analyzer**: Calculate total size, count files by type

---

### Module 6: Practical Problems
**File**: `06_Practice_Problems.py`
**Estimated Time**: 120-180 minutes (homework assignment)

#### Pedagogical Intent
This module provides 10 progressive problems that integrate all concepts from Modules 1-5. Problems are designed to:
- Reinforce object-oriented thinking
- Require selecting appropriate library objects
- Build real-world, practical tools
- Increase in complexity gradually

#### Problem Set Design Principles

1. **Incremental Difficulty**: Problems 1-3 are accessible to all students; 4-7 challenge proficient students; 8-10 are stretch problems for advanced students.

2. **Real-World Relevance**: Every problem simulates a task students might encounter in actual programming work.

3. **Object-Focused**: Each problem requires working with specific standard library objects.

4. **Hidden Solutions**: Solutions are included but hidden (in docstrings or comments) to encourage genuine problem-solving attempts.

#### Problem Breakdown

**Problem 1: Birthday Countdown**
**Concepts**: `datetime` objects, date arithmetic, user input
**Difficulty**: ⭐ Beginner
**Description**: Calculate days until user's next birthday.

```python
"""
Input: User's birth month and day
Output: Days until next birthday, day of week it falls on
Objects Used: datetime.datetime, datetime.date, timedelta
"""
```

**Learning Goal**: Comfortable with datetime creation and arithmetic.

---

**Problem 2: File Extension Reporter**
**Concepts**: `pathlib.Path`, `collections.Counter`, directory iteration
**Difficulty**: ⭐ Beginner
**Description**: Analyze directory and report file count by extension.

```python
"""
Input: Directory path
Output: Dictionary of extensions and counts
Objects Used: Path.iterdir(), Counter
"""
```

**Learning Goal**: Navigate file system with Path objects, use Counter for frequency.

---

**Problem 3: Random Password Generator**
**Concepts**: `random` module, string methods
**Difficulty**: ⭐ Beginner
**Description**: Generate secure random passwords with specified criteria.

```python
"""
Input: Length, include uppercase, include digits, include symbols
Output: Random password string
Objects Used: random.choice(), random.sample(), string constants
"""
```

**Learning Goal**: Control randomness, meet specification requirements.

---

**Problem 4: Study Session Planner**
**Concepts**: `datetime`, `collections.namedtuple`, scheduling logic
**Difficulty**: ⭐⭐ Intermediate
**Description**: Create study schedule with break intervals.

```python
"""
Input: Start time, session duration, break duration, number of sessions
Output: List of Session objects with start/end times
Objects Used: datetime, timedelta, namedtuple('Session', ...)
"""
```

**Learning Goal**: Complex datetime logic, structured data with namedtuple.

---

**Problem 5: JSON Database Manager**
**Concepts**: `json`, `pathlib.Path`, CRUD operations
**Difficulty**: ⭐⭐ Intermediate
**Description**: Simple JSON-based database with add/update/delete/search.

```python
"""
Operations: create(), read(), update(), delete(), find()
Storage: JSON file with auto-save
Objects Used: json.load/dump, Path, dict operations
"""
```

**Learning Goal**: Persistent storage patterns, data manipulation.

---

**Problem 6: Log File Analyzer**
**Concepts**: File I/O, `collections.Counter`, `datetime.strptime()`, statistics
**Difficulty**: ⭐⭐ Intermediate
**Description**: Parse log files, extract patterns, generate analytics.

```python
"""
Input: Log file path (format: "2025-10-16 14:32:10 ERROR: Message")
Output: Error frequency by type, errors by hour, most common errors
Objects Used: Path.read_text(), Counter, datetime.strptime()
"""
```

**Learning Goal**: Text parsing, datetime parsing, data aggregation.

---

**Problem 7: File Organizer with Categories**
**Concepts**: `pathlib.Path`, `collections.defaultdict`, file operations
**Difficulty**: ⭐⭐⭐ Advanced
**Description**: Organize files into category folders based on extension.

```python
"""
Input: Source directory, category mappings (e.g., {'.jpg': 'Images', '.pdf': 'Documents'})
Output: Files moved to category subfolders, summary report
Objects Used: Path.iterdir(), Path.rename(), defaultdict
"""
```

**Learning Goal**: File system manipulation, categorization logic.

---

**Problem 8: Backup System with Versioning**
**Concepts**: `pathlib.Path`, `datetime`, `shutil`, file copying
**Difficulty**: ⭐⭐⭐ Advanced
**Description**: Create timestamped backups, maintain version history.

```python
"""
Features:
- Copy files to backup directory with timestamp
- Keep only last N backups
- Generate backup metadata (size, date, files included)
Objects Used: Path, datetime, shutil.copy2()
"""
```

**Learning Goal**: Complex file operations, version management strategy.

---

**Problem 9: Data Validator with Type Checking**
**Concepts**: `typing`, type checking, validation logic
**Difficulty**: ⭐⭐⭐ Advanced
**Description**: Validate data structures against type specifications.

```python
"""
Input: Data structure, type specification (using typing module)
Output: Validation result with specific error messages
Objects Used: typing.get_type_hints(), isinstance(), type checking
"""
```

**Learning Goal**: Runtime type validation, working with `typing` module.

---

**Problem 10: Statistical Report Generator**
**Concepts**: `statistics`, `json`, `pathlib.Path`, data aggregation
**Difficulty**: ⭐⭐⭐⭐ Challenge
**Description**: Read multiple data files, compute statistics, generate formatted report.

```python
"""
Input: Directory of JSON data files
Output: Comprehensive statistical report (mean, median, stdev, quartiles, outliers)
Features:
- Handle missing data
- Detect outliers
- Generate text-based visualizations (histograms)
Objects Used: statistics module, json, Path.glob(), formatting
"""
```

**Learning Goal**: Integrate multiple modules, complex data processing, professional output.

---

#### Instructor Notes for Module 6

**Grading Approach**:
- Problems 1-5: Core competency (should complete at least 4 of 5)
- Problems 6-8: Proficiency (demonstrates strong understanding)
- Problems 9-10: Mastery (exceeds expectations)

**Common Struggles**:
- **Problem 4**: Date arithmetic confusion (forgetting to accumulate timedelta)
- **Problem 5**: File I/O race conditions (not reloading data between operations)
- **Problem 6**: Regex vs. string methods (teach simple approaches first)
- **Problem 8**: File path construction errors (emphasize Path operations)

**Extension Ideas**:
- Add GUI to any problem (introduce `tkinter` for motivated students)
- Connect Problem 5 to API (make it a simple REST server)
- Extend Problem 10 with data visualization (matplotlib integration)

---

### Module 7: Capstone Project - Personal Library Manager
**File**: `07_library_manager.py`
**Estimated Time**: 180-240 minutes (major project)

#### Pedagogical Intent
This capstone project integrates **all lab concepts** into a cohesive, real-world application. Students build a functional library management system that demonstrates:
- Object-oriented thinking (working with library objects)
- Data persistence (JSON storage with pathlib)
- User interaction (command-line interface)
- Date/time handling (borrow dates, due dates)
- Data organization (collections for cataloging)
- Professional code structure (modular functions, error handling)

#### Project Specification

**System Overview**: A command-line application to manage a personal book/media library.

**Core Features (Required)**:
1. **Add Items**: Add books/media with title, author/creator, genre, acquisition date
2. **List Items**: View all items, optionally filtered by genre or status
3. **Search**: Find items by title, author, or genre (partial matching)
4. **Borrow/Return**: Track lending (who borrowed, when, due date)
5. **Statistics**: Generate reports (total items, most borrowed, overdue)
6. **Data Persistence**: Auto-save to JSON file

**Data Structure**:
```python
{
    "library_name": "My Library",
    "created_date": "2025-10-16",
    "items": [
        {
            "id": "001",
            "type": "book",
            "title": "Python Crash Course",
            "author": "Eric Matthes",
            "genre": "Programming",
            "acquired": "2025-01-15",
            "borrowed_by": None,
            "borrowed_date": None,
            "due_date": None
        },
        # ... more items
    ]
}
```

**Objects Used**:
- `datetime`: Acquisition dates, borrow dates, due dates, overdue calculations
- `pathlib.Path`: Data file management, export file handling
- `json`: Load/save library data
- `collections.Counter`: Genre statistics, borrower statistics
- `collections.defaultdict`: Grouping by genre/author
- `random`: Generate sample library data (for testing)
- `typing`: Type hints for functions

#### Code Structure (Instructor Scaffold)

Provide students with a starter template:

```python
"""
Personal Library Manager - Capstone Project for Lab 06
Manages a personal book/media library with borrowing tracking.
"""

from pathlib import Path
from datetime import datetime, timedelta
from typing import List, Dict, Optional
import json
from collections import Counter, defaultdict

# Type aliases for clarity
Item = Dict[str, str | None]
Library = Dict[str, str | List[Item]]

# Configuration
DATA_FILE = Path("library_data.json")
DEFAULT_LOAN_PERIOD = 14  # days

# --- Data Persistence ---

def load_library() -> Library:
    """Load library data from JSON file, or create new library if file doesn't exist."""
    # TODO: Implement
    pass

def save_library(library: Library) -> None:
    """Save library data to JSON file."""
    # TODO: Implement
    pass

# --- Item Management ---

def add_item(library: Library, item_type: str, title: str, author: str, genre: str) -> Item:
    """Add a new item to the library."""
    # TODO: Implement
    # - Generate unique ID
    # - Create item dict with all fields
    # - Add to library['items']
    # - Auto-save
    pass

def list_items(library: Library, filter_genre: Optional[str] = None) -> List[Item]:
    """List all items, optionally filtered by genre."""
    # TODO: Implement
    pass

def search_items(library: Library, query: str) -> List[Item]:
    """Search items by title, author, or genre (case-insensitive partial match)."""
    # TODO: Implement
    pass

# --- Borrowing Management ---

def borrow_item(library: Library, item_id: str, borrower: str) -> bool:
    """Mark item as borrowed. Returns True if successful."""
    # TODO: Implement
    # - Find item by ID
    # - Check if already borrowed
    # - Set borrowed_by, borrowed_date, due_date
    # - Auto-save
    pass

def return_item(library: Library, item_id: str) -> bool:
    """Mark item as returned. Returns True if successful."""
    # TODO: Implement
    pass

def get_overdue_items(library: Library) -> List[Item]:
    """Return list of items past their due date."""
    # TODO: Implement
    pass

# --- Statistics and Reports ---

def generate_statistics(library: Library) -> Dict[str, any]:
    """Generate library statistics."""
    # TODO: Implement
    # - Total items
    # - Items by genre (Counter)
    # - Currently borrowed count
    # - Most borrowed items (if tracking borrow history)
    pass

def print_report(library: Library) -> None:
    """Print a formatted library report."""
    stats = generate_statistics(library)
    # TODO: Format and print statistics
    pass

# --- User Interface ---

def display_menu() -> None:
    """Display the main menu."""
    print("\n" + "="*50)
    print("Personal Library Manager")
    print("="*50)
    print("1. Add item")
    print("2. List all items")
    print("3. Search items")
    print("4. Borrow item")
    print("5. Return item")
    print("6. Show overdue items")
    print("7. Generate report")
    print("8. Exit")
    print("="*50)

def main():
    """Main application loop."""
    library = load_library()

    while True:
        display_menu()
        choice = input("\nEnter your choice (1-8): ").strip()

        if choice == "1":
            # TODO: Get user input and add item
            pass
        elif choice == "2":
            # TODO: List items
            pass
        elif choice == "3":
            # TODO: Search items
            pass
        elif choice == "4":
            # TODO: Borrow item
            pass
        elif choice == "5":
            # TODO: Return item
            pass
        elif choice == "6":
            # TODO: Show overdue
            pass
        elif choice == "7":
            # TODO: Generate report
            pass
        elif choice == "8":
            print("\nThank you for using Library Manager!")
            break
        else:
            print("Invalid choice. Please try again.")

if __name__ == "__main__":
    main()
```

#### Implementation Guidance

**Phase 1: Data Persistence (20% of project)**
- Implement `load_library()` and `save_library()`
- Handle `FileNotFoundError` gracefully (create new library)
- Test by manually creating a JSON file and loading it

**Phase 2: Basic CRUD Operations (30% of project)**
- Implement `add_item()`, `list_items()`, `search_items()`
- Focus on correct data structure manipulation
- Test each function independently

**Phase 3: Borrowing System (25% of project)**
- Implement `borrow_item()`, `return_item()`, `get_overdue_items()`
- Careful with datetime arithmetic
- Handle edge cases (already borrowed, not found, etc.)

**Phase 4: Statistics and UI (25% of project)**
- Implement `generate_statistics()` and `print_report()`
- Complete the `main()` function with menu handling
- Polish output formatting

#### Enhancement Challenges

**For Advanced Students**:
1. **Borrow History**: Track complete history of borrows/returns (add `history` list to each item)
2. **User Management**: Track multiple library members with their own borrow limits
3. **Export Reports**: Generate formatted reports (markdown, HTML, CSV)
4. **Data Visualization**: Use matplotlib to create charts (genre distribution, borrow trends)
5. **Configuration File**: Allow user to set loan periods, library name, etc. (separate config.json)
6. **Recommendation System**: Suggest items based on genre preferences (use Counter for most-read genres)
7. **ISBN Integration**: Optional API integration to fetch book metadata (requires requests library)
8. **GUI Version**: Build a Tkinter interface (major extension)

#### Assessment Rubric

**Core Functionality (70 points)**:
- Data persistence (load/save): 10 points
- Add/list items: 15 points
- Search functionality: 10 points
- Borrow/return system: 20 points
- Statistics generation: 15 points

**Code Quality (20 points)**:
- Proper use of standard library objects: 8 points
- Type hints and documentation: 5 points
- Error handling: 4 points
- Code organization and readability: 3 points

**User Experience (10 points)**:
- Clear menu and instructions: 4 points
- Informative error messages: 3 points
- Formatted output: 3 points

**Total: 100 points**

#### Common Student Challenges

**Challenge 1: DateTime Calculations**
Students often struggle with calculating due dates and overdue status.

**Solution Approach**:
```python
# Adding days to a date
from datetime import datetime, timedelta

borrow_date = datetime.now()
due_date = borrow_date + timedelta(days=14)

# Checking if overdue
today = datetime.now()
is_overdue = today > due_date
```

**Challenge 2: JSON Datetime Serialization**
`datetime` objects aren't JSON-serializable by default.

**Solution Approach**:
```python
# Convert datetime to string before saving
item['due_date'] = due_date.isoformat()

# Convert string back to datetime when loading
if item['due_date']:
    item['due_date'] = datetime.fromisoformat(item['due_date'])
```

**Challenge 3: Searching with Partial Matches**
Students may not know how to implement case-insensitive partial matching.

**Solution Approach**:
```python
query = query.lower()
results = [
    item for item in library['items']
    if query in item['title'].lower() or query in item['author'].lower()
]
```

---

## Lab-Wide Assessment Strategy

### Formative Assessment (Ongoing)

**Module Exercises**:
- Check for completion (participation grade)
- Provide immediate feedback via office hours or forums
- Focus on effort and understanding, not perfection

**Code Reviews**:
- Select 2-3 students per class session for live code review
- Emphasize learning from mistakes
- Create safe environment for debugging together

### Summative Assessment (Lab Grade)

**Component 1: Module 6 Practice Problems (40%)**
- Submit at least 5 of 10 problems
- Graded on correctness, code quality, and object usage
- Partial credit for good attempts

**Component 2: Capstone Project (50%)**
- Functional library manager with core features
- Use rubric provided in Module 7
- Demonstrations/presentations optional

**Component 3: Conceptual Quiz (10%)**
- Short quiz on OOP concepts (objects, methods, APIs)
- Multiple choice + short answer
- Focus on understanding, not memorization

### Alternative Assessment Options

**For Diverse Learners**:
- **Portfolio**: Curate 3 best solutions with reflection essays
- **Pair Programming**: Complete capstone with partner (both contribute)
- **Video Explanation**: Record explanation of 2 complex problems
- **Extended Project**: Replace Module 6 problems with single larger project

---

## Time Management and Pacing

### Three-Week Schedule (Recommended)

**Week 1: Foundations**
- **Day 1-2**: Module 1 (Variables/Types Review)
- **Day 3-4**: Module 2 (Objects and Methods)
- **Day 5**: Office hours, catch-up, start Module 3

**Week 2: Standard Library Deep Dive**
- **Day 1-3**: Module 3 (Core Objects: datetime, pathlib, random, collections)
- **Day 4-5**: Module 4 (Advanced Objects: json, math, statistics, typing, dataclasses)

**Week 3: Application and Integration**
- **Day 1-2**: Module 5 (File/System Objects), start Module 6
- **Day 3-4**: Module 6 (Practice Problems)
- **Day 5**: Start Module 7 (Capstone Project)
- **Extra Time**: Complete capstone as homework

### Flexible Pacing Options

**Accelerated (2 weeks)**:
- Combine Modules 3-4 into single week
- Assign Module 6 as homework from Day 1
- In-class time focuses on difficult concepts (datetime, file I/O)

**Extended (4 weeks)**:
- Full week on Modules 1-2 (deeper OOP theory)
- Two weeks on Modules 3-5 (more practice time)
- Final week dedicated to capstone with daily check-ins

---

## Common Student Questions and Instructor Responses

### Conceptual Questions

**Q1: "What's the real difference between a method and a function? They both do things."**

**A**: Great question! The key difference is **ownership**. A function is standalone—you pass data to it: `len(my_list)`. A method belongs to an object—you ask the object to perform an action: `my_list.count(5)`. Methods can access the object's internal data (state), while functions work only with what you pass them. Think of it this way: a function is like asking a friend to count items in a box you hand them, while a method is like asking the box itself to report how many items it contains.

**Q2: "Why does `list.sort()` return `None` but `sorted(list)` returns a new list? That's confusing!"**

**A**: This is a deliberate design choice in Python! `list.sort()` is a method that modifies the list in place—it changes the original list, so it returns `None` to signal "I changed myself." `sorted()` is a function that creates a new sorted list and returns it, leaving the original unchanged. The rule: mutable object methods that modify in place return `None` to prevent confusion about whether you got a new object or changed the original. If you want the sorted result, use `sorted()`. If you want to sort the existing list, use `.sort()`.

**Q3: "When should I use `pathlib.Path` vs. `os.path`?"**

**A**: Always use `pathlib.Path` for new code! `os.path` is the old way (Python 2 era) that treats paths as strings. `pathlib.Path` treats paths as objects with methods, making code more readable and cross-platform. Compare: `os.path.splitext(os.path.basename(path))[0]` (old way) vs. `Path(path).stem` (new way). Much cleaner! The only time to use `os.path` is when working with legacy code that requires string paths.

**Q4: "Why are there so many ways to do the same thing in Python? Like `open()` vs. `Path.open()` vs. `Path.read_text()`?"**

**A**: Python evolves over time, adding better ways to do things while keeping old ways for compatibility. Here's when to use each:
- `open()`: Traditional, works everywhere, use for complex file operations
- `Path.open()`: Modern, object-oriented, use when you're already working with Path objects
- `Path.read_text()`: Convenience method for simple "just read the whole file" scenarios

Use the simplest method that fits your needs. For this class, prefer `pathlib` methods.

### Technical Questions

**Q5: "My datetime calculations are giving weird results. What's wrong?"**

**A**: Common issues:
1. **Comparing datetime to date**: Make sure both sides are the same type (`datetime.now()` vs. `date.today()`)
2. **Forgetting to add timedelta**: Can't do `date + 5`, must do `date + timedelta(days=5)`
3. **String comparison instead of date comparison**: Convert strings to datetime objects first
4. **Timezone issues**: `datetime.now()` is "naive" (no timezone). For timezone-aware, use `datetime.now(timezone.utc)`

Show me your code and I'll help debug!

**Q6: "I get `AttributeError: 'str' object has no attribute 'read_text'`. What does this mean?"**

**A**: This error means you're trying to call a Path method on a string. Common mistake:
```python
file_path = "data/file.txt"  # This is a string!
content = file_path.read_text()  # ERROR: strings don't have read_text()

# Fix: Convert to Path first
file_path = Path("data/file.txt")  # Now it's a Path object
content = file_path.read_text()  # Works!
```

**Q7: "My `with open()` code works in Jupyter but fails in my .py file. Why?"**

**A**: Likely a path issue. Jupyter notebooks execute in the directory containing the notebook, while .py scripts might execute from a different directory. Solutions:
```python
# Option 1: Use absolute paths
file_path = Path(__file__).parent / "data" / "file.txt"

# Option 2: Always check if file exists
if file_path.exists():
    with file_path.open() as f:
        ...
else:
    print(f"File not found: {file_path}")
```

### Assignment Questions

**Q8: "How many problems from Module 6 do I need to complete?"**

**A**: Minimum 5 out of 10 for full credit. However, I recommend attempting at least 7-8 to solidify your understanding before the capstone project. Problems 1-5 are essential; choose 2-3 from problems 6-10 based on your interests.

**Q9: "Can I use external libraries not covered in class (like pandas or matplotlib)?"**

**A**: For Module 6 problems, please stick to the standard library to practice the concepts we're learning. For capstone project enhancements, absolutely! Using external libraries shows initiative. Just document what you're using and why.

**Q10: "My capstone project isn't working perfectly. Will I lose a lot of points?"**

**A**: The capstone is graded on functionality, code quality, and effort. If core features work but there are minor bugs, you'll still get most points. I value: (1) proper use of library objects, (2) error handling, (3) code organization, (4) documented attempts at challenges. A project with good structure and minor bugs scores better than a "perfect" project with poor code quality.

---

## Troubleshooting Guide for Instructors

### Technical Issues

**Issue**: Students' code works in Colab but fails locally
**Cause**: Usually file paths or missing imports
**Solution**: Teach relative vs. absolute paths; use `Path(__file__).parent` for script-relative paths

**Issue**: `datetime` errors about "can't compare offset-naive and offset-aware datetimes"
**Cause**: Mixing timezone-aware and naive datetime objects
**Solution**: Stick with naive datetimes for this lab (add timezone handling in advanced courses)

**Issue**: `json.decoder.JSONDecodeError` when loading files
**Cause**: Manually edited JSON with syntax errors
**Solution**: Teach students to use JSON validators (JSONLint); always use `json.dump()` to write

### Pedagogical Challenges

**Challenge**: Students treating objects as passive data (using functions instead of methods)
**Strategy**: Code review exercises where they refactor `len(my_list)` style to `my_list.__len__()` (then explain why Python allows the function form for convenience)

**Challenge**: Students uncomfortable with documentation/API exploration
**Strategy**: "Treasure hunt" activities: give them a task and require finding the solution in official docs (e.g., "Find the method that returns the day of week as an integer")

**Challenge**: Advanced students finish early and get bored
**Strategy**: Maintain list of extension challenges for each module; encourage peer mentoring (pair advanced students with struggling students)

---

## Extensions and Next Steps

### Preparing for Lab 07 (Custom Classes and OOP)

This lab sets the foundation for Lab 07, where students will create their own classes. Key bridges:

1. **Understanding Before Creating**: Students now understand what objects are, so creating them will feel natural
2. **Method Familiarity**: They've used methods extensively; writing their own is the next step
3. **API Design**: They've seen consistent API patterns in standard library; they'll apply these principles to their classes
4. **Dataclasses Preview**: Module 4 introduces dataclasses, which are a gentle introduction to class syntax

### Lab 07 Preview Topics

- Defining classes with `__init__`
- Instance vs. class attributes
- Writing methods (including `__str__`, `__repr__`)
- Encapsulation and private attributes
- Inheritance basics
- Operator overloading (`__add__`, `__eq__`, etc.)

### Integration with Course Projects

**Consider**: Making the Lab 06 capstone project a foundation for a semester-long project:
- Lab 07: Convert library manager to use custom `Book`, `LibraryMember` classes
- Lab 08: Add database integration (SQLite)
- Lab 09: Build web interface (Flask)
- Final Project: Full-stack library management system

---

## Resources for Instructors

### Official Python Documentation
- [Python Standard Library](https://docs.python.org/3/library/index.html)
- [datetime module](https://docs.python.org/3/library/datetime.html)
- [pathlib module](https://docs.python.org/3/library/pathlib.html)
- [collections module](https://docs.python.org/3/library/collections.html)
- [typing module](https://docs.python.org/3/library/typing.html)

### Teaching Resources
- [Real Python - OOP in Python](https://realpython.com/python3-object-oriented-programming/)
- [Python Tutor - Visualize Execution](https://pythontutor.com/)
- [PEP 8 - Style Guide](https://pep8.org/)

### Additional Practice Problems
- [Exercism Python Track](https://exercism.org/tracks/python) - Focus on filtering problems that use standard library
- [Python Morsels](https://www.pythonmorsels.com/) - Weekly Python exercises (some free)

---

## Conclusion

Lab 06 is a **pivotal** moment in the course. Students transition from writing procedural code with primitive types to thinking in objects and leveraging Python's rich standard library. This lab:

- **Consolidates** previous learning (variables, data structures, file I/O)
- **Transforms** mental models (from procedural to object-oriented)
- **Prepares** for advanced topics (custom classes, design patterns)
- **Builds** practical skills (working with dates, files, data)

By the end of this lab, students should feel confident:
- Reading and understanding API documentation
- Selecting appropriate library objects for tasks
- Writing modular, object-oriented code
- Tackling real-world programming challenges

This confidence will serve them throughout their programming careers, as working effectively with libraries is a core skill for professional developers.

---

**Good luck with Lab 06! Feel free to adapt this script to your teaching style and class needs.**
